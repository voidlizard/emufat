 emufat 0.9
 ==========

 HELP!
 ---------------

 Translated the following text to English using "Google Translate" Russian to English.

 Main functions
 ----------------

   - Generation rules for emulation FAT32
   - Generate stubs to play the compiled rules
   - Automatic tests

 Principle of operation
 --------------

 For a description of the file system in the form EDSL

	 helloFile = const $ BS8.pack "HELLO WORLD !!"

	 fatSample2 = filesystem $ do
	   file "file0" (16384) helloFile 
	   dir "A" $ do
		 file "file1" (megs 100) helloFile 
		 dir "C" $ do
		   file "file3" (megs 100) helloFile 
		   file "file4" (megs 100) helloFile 
		   file "file5" (megs 100) helloFile 
		   dir "E" $ emptyDir 


 is generated by a set of rules such as RANGE ab and REQ a.  Terms of getting the sector
 range and in comparison with a given sector, respectively.  These rules 
 compiled into pseudo-fort and are grouped in the form of a binary tree with comparisons 
 height ~ Log N with respect to the number of inspections. 

 Each rule is put under some Forth code, pursuant to which
 It leads to the generation of the content sector.

 For dynamic content (files) provides the ability to call callbacks.
 Each callback receives the input of their "closure" (void * pointer to the context,
 is initialized by the user may be 0), and the buffer after execution rules
 for the sector.  It is assumed that the buffer will contain e.g.
 sishnuyu structure with a file identifier and the URL of the stream, but this way.

 It is assumed that the contents of buffer callback determines what data
 it should be placed, and a buffer overwrites that data.

 For the curious.  The rule that looks like this (the contents of the file above):

     RANGE 2122 821353 [SEQ [48 45]
                        RLE 2 76
                        SEQ [4F 4F 20 57 52 4C 44]
                        RLE 2 33
                        CALLBACK 0]

 It will be compiled about the following code:

     L215:
         DUP
         CONST 2122
         JGQ L220
         DUP
         CRNG 00000843 00000849
         JZ L235
         RLE512 00
         EXIT
     L220:
         DUP
         CRNG 0000084A 000C8869 ;;  We check to get into range
         JZ L223 ;;  if you do not put something in the garden ---
         LOADS2 ;;  otherwise write to the output buffer string 'HELLO WORLD !!'
         BYTE 48
         BYTE 45
         RLE2 4C
         LOADS7
         BYTE 4F
         BYTE 20
         BYTE 57
         BYTE 4F
         BYTE 52
         BYTE 4C
         BYTE 44
         RLE2 21
         CALLN 00 ;;  and call the callback
         EXIT

 The compiler attempts to optimize the code, for example, to cut the chain JMP
 and partly make repetitive code in a function (see. CALL / RET).

 See. FatGen, TestVM and cbits / teststubs.c for details.

 Virtual Machine, and other rules to play stubs are generated 
 automatically (FatGen).

 API provides a file FatGenAPI, look for examples of usage 
 FatGen.hs

 Known Problems and Limitations
 --------------------------------

   - Long file names (LFN) are not supported

   - The small size of the cluster (CL_512) and a large area of â€‹â€‹data 
     can lead to inhibition ZHoru memory and

   - Copy and fill the buffer written suboptimal,
     but securely Buffer is handled as circular, in case of overflow
     rewritten again.  This leads to a check-out for overseas
     each byte.  Perhaps for reasons of performance is 
     rewrite them in a way that would determine the distance to the border
     and copy it to the standard functions (memset, memcpy, etc.)
     It remains at the discretion.

   - The generated code (rules) can be further reduced


 Assembly
 ------

 I should work make config && make all.
 If does not work - see the makefiles

 Testing
 ------------

 Should work make test
 This command run test cases to generate, compile and play
 rules.

 See. TestVM.hs for a more detailed description of the tests.

 If you do not see the Makefile works ---

 The principle of the test: each test case generates a sequence of bytecodes, 
 These bytecodes enter the STDIN to cbits / teststubs, the result is read from STDOUT, and
 compared with the sample.

 Examples:

   ./TestVM Run cbits / teststubs

   ./TestVM Dump testCallRet1 |  cbits / teststubs |  hexdump -C

 the latest example lets see what compile and test case 
 that is the result of his playing.

 TestVM prompts for parameters when you start without them.


 Run the file
 -----------------

 FatGen
 ~~~~~~

   - Generate stubs C
   - Compilation of rules
   - Example of FatGenAPI
   - For tips on commands run without parameters


 TestVM
 ~~~~~~

 Tests VM


 cbits / teststubs
 ~~~~~~~~~~~~~~~

 Test shell for testing rules.  Gets the binary rules
 in STDIN, writes the result to STDOUT.

 The parameter is the number of sectors, defaults to 0.

 File size rule is assumed to be more than 16Kb.

 cbits / genfat
 ~~~~~~~~~~~~~~~

 Image generator FAT.  The STDIN received a binary file with the rules to STDOUT 
 He writes the result.  --- Setting the number of 512-byte sectors to generate.

 File size rule is assumed to be more than 16Kb.

 Example:

     ./FatGen Bin |  cbits / genfat 1200000> fat.img

